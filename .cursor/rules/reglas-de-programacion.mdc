---
description: "Reglas de programacion para Parcial2_sistemasoperativos"
alwaysApply: true
---
# Reglas de Programaci√≥n - Procesamiento de Im√°genes en C

## üéØ OBJETIVO DEL PROYECTO
Extender un programa base de procesamiento de im√°genes en C manteniendo:
- Simplicidad educativa para principiantes
- Robustez en manejo de memoria
- Concurrencia con pthreads
- Compatibilidad con im√°genes grayscale (1 canal) y RGB (3 canales)

---

## üîí REGLAS INMUTABLES

### 1. NO MODIFICAR C√ìDIGO BASE
- **NUNCA** alteres las funciones existentes: cargarImagen(), liberarImagen(), 
  mostrarMatriz(), guardarPNG(), ajustarBrilloConcurrente()
- **EXCEPCI√ìN**: Solo modifica main() y mostrarMenu() para agregar opciones
- Usa las funciones base como referencia de estilo y estructura

### 2. ESTRUCTURA DE DATOS OBLIGATORIA
```c
typedef struct {
    int ancho;
    int alto;
    int canales;                    // SIEMPRE 1 o 3
    unsigned char*** pixeles;       // Matriz 3D: [alto][ancho][canales]
} ImagenInfo;

NUNCA uses arreglos 1D para p√≠xeles
SIEMPRE usa matriz 3D con notaci√≥n pixeles[y][x][c]
SIEMPRE verifica info->pixeles != NULL antes de procesar

3. SOPORTE DUAL DE FORMATOS
Todas las funciones nuevas DEBEN:

‚úÖ Funcionar con grayscale (canales = 1)
‚úÖ Funcionar con RGB (canales = 3)
‚úÖ Iterar sobre canales con for (int c = 0; c < info->canales; c++)
‚ùå NUNCA asumir un n√∫mero fijo de canales


üßµ CONCURRENCIA OBLIGATORIA
4. IMPLEMENTACI√ìN DE HILOS
Todas las funciones nuevas DEBEN usar pthreads:
c// Estructura de argumentos (ejemplo)
typedef struct {
    unsigned char*** pixeles;       // O puntero a matriz origen/destino
    int inicio;                     // Fila inicial (inclusiva)
    int fin;                        // Fila final (exclusiva)
    int ancho;
    int canales;
    // ... otros par√°metros espec√≠ficos
} TuFuncionArgs;

// Funci√≥n del hilo
void* tuFuncionHilo(void* args) {
    TuFuncionArgs* tArgs = (TuFuncionArgs*)args;
    // Procesar desde tArgs->inicio hasta tArgs->fin
    return NULL;
}

// Funci√≥n principal concurrente
void tuFuncionConcurrente(ImagenInfo* info, /* otros params */) {
    const int numHilos = 2;  // M√≠nimo 2, idealmente 2-4
    pthread_t hilos[numHilos];
    TuFuncionArgs args[numHilos];
    
    int filasPorHilo = (int)ceil((double)info->alto / numHilos);
    
    for (int i = 0; i < numHilos; i++) {
        args[i].inicio = i * filasPorHilo;
        args[i].fin = ((i + 1) * filasPorHilo < info->alto) 
                      ? (i + 1) * filasPorHilo 
                      : info->alto;
        // Configurar otros campos...
        
        if (pthread_create(&hilos[i], NULL, tuFuncionHilo, &args[i]) != 0) {
            fprintf(stderr, "Error al crear hilo %d\n", i);
            return;
        }
    }
    
    for (int i = 0; i < numHilos; i++) {
        pthread_join(hilos[i], NULL);
    }
}
REQUISITOS:

‚úÖ Divisi√≥n de trabajo por filas (m√°s simple para principiantes)
‚úÖ M√≠nimo 2 hilos, recomendado 2-4
‚úÖ Manejo de errores en pthread_create()
‚úÖ Sincronizaci√≥n con pthread_join()
‚ùå NO usar mutex (dise√±a para evitar race conditions)
‚ùå NO usar variables globales compartidas escritas


üíæ GESTI√ìN DE MEMORIA CR√çTICA
5. ASIGNACI√ìN Y LIBERACI√ìN
c// ASIGNACI√ìN de matriz 3D (patr√≥n obligatorio)
unsigned char*** asignarMatriz3D(int alto, int ancho, int canales) {
    unsigned char*** matriz = malloc(alto * sizeof(unsigned char**));
    if (!matriz) return NULL;
    
    for (int y = 0; y < alto; y++) {
        matriz[y] = malloc(ancho * sizeof(unsigned char*));
        if (!matriz[y]) {
            // Liberar filas ya asignadas
            for (int yy = 0; yy < y; yy++) {
                for (int x = 0; x < ancho; x++) free(matriz[yy][x]);
                free(matriz[yy]);
            }
            free(matriz);
            return NULL;
        }
        
        for (int x = 0; x < ancho; x++) {
            matriz[y][x] = malloc(canales * sizeof(unsigned char));
            if (!matriz[y][x]) {
                // Liberar p√≠xeles de esta fila
                for (int xx = 0; xx < x; xx++) free(matriz[y][xx]);
                free(matriz[y]);
                // Liberar filas anteriores
                for (int yy = 0; yy < y; yy++) {
                    for (int xx = 0; xx < ancho; xx++) free(matriz[yy][xx]);
                    free(matriz[yy]);
                }
                free(matriz);
                return NULL;
            }
        }
    }
    return matriz;
}

// LIBERACI√ìN de matriz 3D (patr√≥n obligatorio)
void liberarMatriz3D(unsigned char*** matriz, int alto, int ancho) {
    if (!matriz) return;
    for (int y = 0; y < alto; y++) {
        if (matriz[y]) {
            for (int x = 0; x < ancho; x++) {
                free(matriz[y][x]);
            }
            free(matriz[y]);
        }
    }
    free(matriz);
}
REGLAS:

‚úÖ SIEMPRE verifica retorno de malloc() antes de usar
‚úÖ SIEMPRE libera en orden inverso: canales ‚Üí columnas ‚Üí filas
‚úÖ Para funciones que crean nueva matriz: libera la antigua con liberarImagen()
‚úÖ Actualiza info->pixeles, info->ancho, info->alto despu√©s de reemplazar
‚ùå NUNCA dejes memoria sin liberar
‚ùå NUNCA uses memoria despu√©s de free()

6. FLUJO DE MEMORIA EN FUNCIONES
cvoid tuFuncionQueModificaTama√±o(ImagenInfo* info, /* params */) {
    // 1. Crear nueva matriz
    unsigned char*** nueva = asignarMatriz3D(nuevoAlto, nuevoAncho, info->canales);
    if (!nueva) {
        fprintf(stderr, "Error de memoria\n");
        return;
    }
    
    // 2. Procesar (con hilos) usando info->pixeles (origen) y nueva (destino)
    // ...
    
    // 3. Liberar matriz original
    liberarMatriz3D(info->pixeles, info->alto, info->ancho);
    
    // 4. Actualizar estructura
    info->pixeles = nueva;
    info->ancho = nuevoAncho;
    info->alto = nuevoAlto;
    // info->canales se mantiene o actualiza seg√∫n funci√≥n
}

üßÆ OPERACIONES MATRICIALES
7. ACCESO A P√çXELES
c// CORRECTO: Notaci√≥n clara y segura
unsigned char valor = info->pixeles[y][x][c];

// Para operaciones, siempre verifica l√≠mites
if (y >= 0 && y < info->alto && x >= 0 && x < info->ancho) {
    unsigned char valor = info->pixeles[y][x][c];
}
8. CONVOLUCI√ìN (Reglas espec√≠ficas)
c// Kernel: matriz 2D, tama√±o impar (3x3, 5x5)
float** kernel = malloc(tamKernel * sizeof(float*));
for (int i = 0; i < tamKernel; i++) {
    kernel[i] = malloc(tamKernel * sizeof(float));
}

// Aplicaci√≥n:
int offset = tamKernel / 2;
for (int y = 0; y < alto; y++) {
    for (int x = 0; x < ancho; x++) {
        for (int c = 0; c < canales; c++) {
            float suma = 0.0f;
            for (int ky = -offset; ky <= offset; ky++) {
                for (int kx = -offset; kx <= offset; kx++) {
                    int ny = y + ky;
                    int nx = x + kx;
                    
                    // MANEJO DE BORDES: Replicar p√≠xeles
                    if (ny < 0) ny = 0;
                    if (ny >= alto) ny = alto - 1;
                    if (nx < 0) nx = 0;
                    if (nx >= ancho) nx = ancho - 1;
                    
                    suma += pixeles[ny][nx][c] * kernel[ky+offset][kx+offset];
                }
            }
            // Clamp a 0-255
            int resultado = (int)(suma + 0.5f);  // Redondeo
            pixelesDestino[y][x][c] = (resultado < 0) ? 0 : 
                                      (resultado > 255) ? 255 : resultado;
        }
    }
}

// Liberar kernel
for (int i = 0; i < tamKernel; i++) free(kernel[i]);
free(kernel);
REQUISITOS:

‚úÖ Kernel normalizado (suma = 1.0 para blur, puede variar para edge detection)
‚úÖ Bordes: replicar p√≠xeles de borde (no zero-padding)
‚úÖ Clamp resultado a [0, 255]
‚úÖ Procesar cada canal independientemente

9. INTERPOLACI√ìN BILINEAL
c// Para coordenadas fraccionarias (x', y') en imagen origen
unsigned char interpolar(unsigned char*** img, float x, float y, int c, 
                        int ancho, int alto) {
    int x0 = (int)floor(x);
    int y0 = (int)floor(y);
    int x1 = x0 + 1;
    int y1 = y0 + 1;
    
    // Clamp a l√≠mites
    if (x0 < 0) x0 = 0;
    if (y0 < 0) y0 = 0;
    if (x1 >= ancho) x1 = ancho - 1;
    if (y1 >= alto) y1 = alto - 1;
    
    float a = x - x0;  // Parte fraccionaria
    float b = y - y0;
    
    float v00 = img[y0][x0][c];
    float v10 = img[y0][x1][c];
    float v01 = img[y1][x0][c];
    float v11 = img[y1][x1][c];
    
    float resultado = (1-a)*(1-b)*v00 + a*(1-b)*v10 + (1-a)*b*v01 + a*b*v11;
    return (unsigned char)(resultado + 0.5f);  // Redondeo
}

üìã INTEGRACI√ìN AL MEN√ö
10. PATR√ìN DE INTEGRACI√ìN
c// En mostrarMenu()
void mostrarMenu() {
    printf("\n--- Plataforma de Edici√≥n de Im√°genes ---\n");
    printf("1. Cargar imagen PNG\n");
    printf("2. Mostrar matriz de p√≠xeles\n");
    printf("3. Guardar como PNG\n");
    printf("4. Ajustar brillo (+/- valor) concurrentemente\n");
    printf("5. [TU NUEVA FUNCI√ìN]\n");  // <-- Agregar aqu√≠
    // ...
    printf("N. Salir\n");  // <-- √öltima opci√≥n
    printf("Opci√≥n: ");
}

// En main(), dentro del switch
case 5: {  // Tu nueva funci√≥n
    // 1. Validar imagen cargada
    if (!imagen.pixeles) {
        printf("Primero carga una imagen (opci√≥n 1).\n");
        break;
    }
    
    // 2. Solicitar par√°metros
    int param1;
    printf("Ingresa par√°metro 1: ");
    if (scanf("%d", &param1) != 1) {
        while (getchar() != '\n');
        printf("Entrada inv√°lida.\n");
        break;
    }
    while (getchar() != '\n');  // Limpiar buffer
    
    // 3. Validar par√°metros
    if (param1 <= 0) {
        printf("Par√°metro inv√°lido.\n");
        break;
    }
    
    // 4. Llamar funci√≥n
    tuFuncionConcurrente(&imagen, param1);
    break;
}
REQUISITOS:

‚úÖ Validar imagen.pixeles != NULL antes de procesar
‚úÖ Limpiar buffer con while(getchar() != '\n') despu√©s de scanf()
‚úÖ Validar par√°metros antes de llamar funci√≥n
‚úÖ Mostrar mensajes informativos (dimensiones, formato, √©xito)
‚úÖ "Salir" SIEMPRE es la √∫ltima opci√≥n


‚úÖ VALIDACI√ìN Y ERRORES
11. MANEJO DE ERRORES OBLIGATORIO
c// SIEMPRE verifica:
if (!info || !info->pixeles) {
    fprintf(stderr, "Error: No hay imagen cargada\n");
    return;
}

if (malloc_result == NULL) {
    fprintf(stderr, "Error: Memoria insuficiente\n");
    // Liberar memoria ya asignada
    return;
}

if (pthread_create(...) != 0) {
    fprintf(stderr, "Error al crear hilo %d\n", i);
    // Cancelar hilos ya creados o manejar error
    return;
}
12. MENSAJES AL USUARIO
c// BUENOS mensajes (informativos, no t√©cnicos)
printf("Imagen cargada: %dx%d, %d canales (%s)\n", 
       info->ancho, info->alto, info->canales,
       info->canales == 1 ? "grises" : "RGB");

printf("Aplicando desenfoque con kernel %dx%d, sigma=%.2f...\n", 
       tamKernel, tamKernel, sigma);

printf("Rotaci√≥n completada. Nuevas dimensiones: %dx%d\n", 
       info->ancho, info->alto);

// MALOS mensajes (evitar)
printf("malloc failed\n");  // Demasiado t√©cnico
printf("Done\n");            // Poco informativo

üîß COMPILACI√ìN Y DEPENDENCIAS
13. COMPILACI√ìN OBLIGATORIA
bash# Comando est√°ndar
gcc -o img img_base.c -pthread -lm

# Con warnings (recomendado para desarrollo)
gcc -o img img_base.c -pthread -lm -Wall -Wextra

# Con optimizaci√≥n (opcional)
gcc -o img img_base.c -pthread -lm -O2
REQUISITOS:

‚úÖ -pthread: Soporte para pthreads
‚úÖ -lm: Librer√≠a matem√°tica (sin, cos, sqrt, etc.)
‚úÖ Debe compilar sin warnings en gcc/clang

14. DEPENDENCIAS PERMITIDAS
c// PERMITIDAS (ya en el c√≥digo base)
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
#include <math.h>
#include "stb_image.h"
#include "stb_image_write.h"

// PROHIBIDAS (no agregar)
#include <opencv2/...>    // ‚ùå
#include <pthread_np.h>   // ‚ùå (no portable)
#include <omp.h>          // ‚ùå (usar pthreads)

üìù ESTILO Y DOCUMENTACI√ìN
15. COMENTARIOS QU√â/C√ìMO/POR QU√â
c// QU√â: Aplica desenfoque Gaussiano mediante convoluci√≥n.
// C√ìMO: Genera kernel, divide trabajo entre hilos, interpola bordes.
// POR QU√â: Suaviza la imagen para reducir ruido o preparar para otras operaciones.
void aplicarConvolucionConcurrente(ImagenInfo* info, int tamKernel, float sigma) {
    // Implementaci√≥n...
}
REQUISITOS:

‚úÖ Documentar todas las funciones nuevas con QU√â/C√ìMO/POR QU√â
‚úÖ Comentar bloques complejos (algoritmos, c√°lculos matem√°ticos)
‚úÖ Usar nombres descriptivos en espa√±ol (consistente con c√≥digo base)
‚ùå NO comentar obviedades (i++; // incrementar i)

16. NOMENCLATURA
c// Variables: camelCase
int nuevoAncho, filasPorHilo, numHilos;

// Funciones: camelCase, sufijo "Concurrente" si usa hilos
void aplicarConvolucionConcurrente(...);
void rotarImagenConcurrente(...);

// Estructuras: PascalCase con sufijo "Args" para argumentos de hilos
typedef struct {
    ...
} ConvolucionArgs;

// Constantes: MAYUSCULAS_CON_GUION
#define MAX_HILOS 8

üß™ TESTING Y CALIDAD
17. PRUEBAS OBLIGATORIAS
Antes de considerar completada una funci√≥n:
bash# 1. Compilaci√≥n sin warnings
gcc -o img img_base.c -pthread -lm -Wall -Wextra

# 2. Probar con imagen grayscale
./img imagen_gris.png

# 3. Probar con imagen RGB
./img imagen_rgb.png

# 4. Verificar memory leaks (si tienes valgrind)
valgrind --leak-check=full ./img imagen.png

# 5. Probar casos l√≠mite
# - Im√°genes peque√±as (1x1, 10x10)
# - Im√°genes grandes (1000x1000+)
# - Par√°metros inv√°lidos (0, negativos)
18. CHECKLIST POR FUNCI√ìN

 Compila sin warnings
 Funciona con grayscale (1 canal)
 Funciona con RGB (3 canales)
 Usa 2+ hilos correctamente
 Sin memory leaks (verificado con valgrind o manualmente)
 Valida par√°metros de entrada
 Maneja errores de memoria
 Mensajes informativos al usuario
 Documentaci√≥n QU√â/C√ìMO/POR QU√â
 Integrada al men√∫ correctamente


üö´ PROHIBICIONES ABSOLUTAS
19. NO HACER BAJO NINGUNA CIRCUNSTANCIA
‚ùå Modificar ImagenInfo (estructura base)
‚ùå Cambiar firma de funciones base
‚ùå Usar arreglos 1D para p√≠xeles
‚ùå Asumir canales = 3 siempre
‚ùå Crear variables globales modificables
‚ùå Usar goto
‚ùå Ignorar retornos de malloc(), pthread_create()
‚ùå Dejar memoria sin liberar
‚ùå Compilar con warnings
‚ùå Agregar dependencias externas (excepto stb)

üìê FUNCIONES REQUERIDAS (Resumen)
20. ESPECIFICACIONES M√çNIMAS
Funci√≥n 1: Convoluci√≥n (Desenfoque Gaussiano)
cvoid aplicarConvolucionConcurrente(ImagenInfo* info, int tamKernel, float sigma);

Genera kernel Gaussiano: G(x,y) = (1/(2œÄœÉ¬≤)) * e^(-(x¬≤+y¬≤)/(2œÉ¬≤))
Normaliza kernel
Maneja bordes por replicaci√≥n
2-4 hilos por filas

Funci√≥n 2: Rotaci√≥n
cvoid rotarImagenConcurrente(ImagenInfo* info, float angulo);

√Ångulo en grados, convierte a radianes
Matriz de rotaci√≥n + interpolaci√≥n bilineal
Crea nueva matriz con nuevas dimensiones
2-4 hilos por filas del destino

Funci√≥n 3: Detecci√≥n de Bordes (Sobel)
cvoid detectarBordesConcurrente(ImagenInfo* info);

Kernels Sobel X e Y predefinidos
Magnitud: sqrt(Gx¬≤ + Gy¬≤)
Convierte RGB a grayscale si necesario
Resultado siempre grayscale (1 canal)
2-4 hilos por filas

Funci√≥n 4: Escalado (Resize)
cvoid escalarImagenConcurrente(ImagenInfo* info, int nuevoAncho, int nuevoAlto);

Interpolaci√≥n bilineal
Factores de escala: ancho_orig / nuevo_ancho
Crea nueva matriz
2-4 hilos por filas del destino


üéì FILOSOF√çA DEL PROYECTO
21. PRINCIPIOS GU√çA

Simplicidad sobre optimizaci√≥n: C√≥digo claro para principiantes
Robustez sobre velocidad: Validar todo, manejar errores
Educaci√≥n sobre producci√≥n: Comentarios extensos, estructura clara
Consistencia sobre innovaci√≥n: Seguir patrones del c√≥digo base
Seguridad sobre conveniencia: Liberar memoria, verificar l√≠mites


‚ú® BONUS: MEJORAS OPCIONALES
22. MEJORAS POST-IMPLEMENTACI√ìN (No obligatorias)

N√∫mero de hilos configurable por usuario
Timer para medir rendimiento (clock_gettime())
Barra de progreso para operaciones largas
Histograma de p√≠xeles
Conversi√≥n de formatos (RGB ‚Üî grayscale como opci√≥n)
Filtros adicionales (sharpen, emboss, median)


üìû AYUDA Y RECURSOS
23. CUANDO TENGAS DUDAS

Revisa ajustarBrilloConcurrente() como referencia
Compila frecuentemente para detectar errores temprano
Prueba con im√°genes peque√±as primero (10x10)
Usa printf() debug para verificar valores
Valgrind es tu amigo para memory leaks

24. COMANDOS √öTILES
bash# Crear imagen de prueba peque√±a (con ImageMagick)
convert -size 10x10 xc:gray50 test_gray.png
convert -size 10x10 plasma: test_rgb.png

# Verificar formato de imagen
file imagen.png

# Debugging con gdb
gcc -g -o img img_base.c -pthread -lm
gdb ./img

‚úÖ CHECKLIST FINAL
Antes de considerar el proyecto completo:

 4 funciones nuevas implementadas y probadas
 Todas usan concurrencia (2+ hilos)
 Funcionan con grayscale Y RGB
 Integradas al men√∫ correctamente
 Compila sin warnings
 Sin memory leaks
 Documentaci√≥n QU√â/C√ìMO/POR QU√â completa
 Probadas con im√°genes reales
 README.md con instrucciones